# 基于PEP8的python代码编写标准 #

## 一.缩进 ##
  每一级缩进4个字节。  
  续行应该与其包裹元素对齐，要么使用圆括号、方括号和花括号内的隐式行连接来垂直对齐，要么使用挂行缩进对齐3。当使用挂行缩进时，应该考虑到第一行不应该有参数，以及使用缩进以区分自己是续行。   
  形如： 
 
	# 用更多的缩进来与其他行区分
	# 没有使用垂直对齐时，禁止把参数放在第一行
	# 当缩进没有与其他行区分时，要增加缩进
    def long_function_name(
			var_one, var_two, var_three,
			var_four):
		print (var_one)

	# 挂行缩进应该再换一行
	foo = long_function_name(
		var_one, var_two,
		var_three, var_four)

  当if语句的条件部分长到需要换行写的时候，注意可以在两个字符关键字的连接处（比如if），增加一个空格，再增加一个左括号来创造一个4空格缩进的多行条件。这会与if语句内同样使用4空格缩进的代码产生视觉冲突。PEP没有明确指明要如何区分i发的条件代码和内嵌代码。  
  形如： 
	
	#在条件判断语句添加额外的缩进
	if (this_is_one_thing
        	and this_is_another_thing):
		do_something()

  在多行结构中的大括号/中括号/小括号的右括号可以与内容对齐单独起一行作为最后一行的第一个字符
  形如：

	my_list = [
		1, 2, 3,
		4, 5, 6,
		7, 8, 9
		]

	result = some_function_that_takes_arguments(
		'a', 'b', 'c',
		'd', 'e', 'f'
		)
	

## 二.单行最大长度 ##

  python标准库比较保守，需要将行宽限制在79个字符（文档/注释限制在72）。 
  较长的代码行选择Python在小括号，中括号以及大括号中的隐式续行方式。通过小括号内表达式的换行方式将长串折成多行。这种方式应该优先使用，而不是使用反斜杠续行。 
  反斜杠有时依然很有用。比如，比较长的，多个with状态语句，不能使用隐式续行，所以反斜杠是可以接受的：  

	with open('/path/to/some/file/you/want/to/read') as file_1, \
     	 open('/path/to/some/file/being/written', 'w') as file_2:
     	 file_2.write(file_1.read())


## 三.二元操作符 ##

  为了解决这种可读性的问题，数学家和他们的出版商遵循了相反的约定。Donald Knuth在他的Computers and Typesetting系列中解释了传统规则：“尽管段落中的公式总是在二元运算符和关系之后中断，显示出来的公式总是要在二元运算符之前中断”4。 
  遵循数学的传统能产出更多可读性高的代码

	# 推荐：运算符和操作数很容易进行匹配
	income = (gross_wages
          	+ taxable_interest
          	+ (dividends - qualified_dividends)
          	- ira_deduction
          	- student_loan_interest)


## 四.空行 ##

  顶层函数和类的定义，前后用两个空行隔开。 
  类里的方法定义用一个空行隔开。


## 五.导入 ##
导入通常在分开的行

导入总是位于文件的顶部，在模块注释和文档字符串之后，在模块的全局变量与常量之前。 
导入应该按照以下顺序分组：

标准库导入
相关第三方库导入
本地应用/库特定导入 

你应该在每一组导入之间加入空行。
推荐使用绝对路径导入，如果导入系统没有正确的配置（比如包里的一个目录在sys.path里的路径后），使用绝对路径会更加可读并且性能更好。

标准库要避免使用复杂的包引入结构，而总是使用绝对路径。 
不应该使用隐式相对路径导入，并且在Python 3中删除了它。
	
	#推荐 
	import os
	import sys

	#不推荐  
	import sys, os

	import mypkg.sibling
	from mypkg import sibling
	from mypkg.sibling import example

当从一个包含类的模块中导入类时，常常这么写：

	from myclass import MyClass
	from foo.bar.yourclass import YourClass

如果上述的写法导致名字的冲突，那么这么写：

	import myclass
	import foo.bar.yourclass

## 六.模块级的“呆”名 ##

像__all__ , __author__ , __version__ 等这样的模块级“呆名“（也就是名字里有两个前缀下划线和两个后缀下划线），应该放在文档字符串的后面，以及除from __future__ 之外的import表达式前面。Python要求将来在模块中的导入，必须出现在除文档字符串之外的其他代码之前。 

	"""This is the example module.

	This module does stuff.
	"""

	from __future__ import barry_as_FLUFL

	__all__ = ['a', 'b', 'c']
	__version__ = '0.1'
	__author__ = 'Cardinal Biggles'

	import os
	import sys

## 七.字符串引号 ##
使用双引号标识字符串变量

## 八.表达式与语句中的空格 ##
紧跟在小括号，中括号或者大括号后

	Yes: spam(ham[1], {eggs: 2})

紧贴在逗号、分号或者冒号之前。

	Yes: if x == 4: print x, y; x, y = y, x

冒号在切片中就像二元运算符，在两边应该有相同数量的空格（把它当做优先级最低的操作符）。在扩展的切片操作中，所有的冒号必须有相同的间距。切片中我们选择无空格。

	ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
	ham[lower:upper], ham[lower:upper:], ham[lower::step]

紧贴在函数参数的左括号之前

	Yes: spam(1)

紧贴索引或者切片的左括号之前

	Yes: dct['key'] = lst[index]

为了和另一个赋值语句对齐，在赋值运算符附件加多个空格（变量 赋值与变量之间隔一空格）

	x = 1
	y = 2
	long_variable = 3

## 九.细节建议 ##

避免在尾部添加空格。   
总是在二元运算符两边加一个空格   
如果使用具有不同优先级的运算符，请考虑在具有最低优先级的运算符周围添加空格。有时需要通过自己来判断；但是，不要使用一个以上的空格，并且在二元运算符的两边使用相同数量的空格。 

	hypot2 = x*x + y*y
	c = (a+b) * (a-b)

在制定关键字参数或者默认参数值的时候，不要在=附近加上空格。 

	def complex(real, imag=0.0):
    return magic(r=real, i=imag)

功能型注释应该使用冒号的一般性规则，并且在使用->的时候要在两边加空格。

	def munge(input: AnyStr): ...
	def munge() -> AnyStr: ...

复合语句(同一行中的多个语句)通常是不允许的

	if foo == 'blah':
    	do_blah_thing()
	do_one()
	do_two()
	do_three()

## 十.注释 ##

注释应该是完整的句子。如果一个注释是一个短语或句子，它的第一个单词应该大写，除非它是以小写字母开头的标识符(永远不要改变标识符的大小写！)。     
如果注释很短，结尾的句号可以省略。块注释一般由完整句子的一个或多个段落组成，并且每句话结束有个句号。       
在句尾结束的时候应该使用两个空格。     
当用英文书写时，遵循Strunk and White （译注：《Strunk and White, The Elements of Style》）的书写风格。      
在非英语国家的Python程序员，请使用英文写注释，除非你120%的确信你的代码不会被使用其他语言的人阅读。    

**Block Comments 块注释**   
  块注释通常适用于跟随它们的某些（或全部）代码，并缩进到与代码相同的级别。块注释的每一行开头使用一个#和一个空格（除非块注释内部缩进文本）。 
  块注释内部的段落通过只有一个#的空行分隔。
  （写在代码块前）

**Inline Comments 行内注释**       
  有节制地使用行内注释。 
  行内注释是与代码语句同行的注释。行内注释和代码至少要有两个空格分隔。注释由#和一个空格开始。 
  事实上，如果状态明显的话，行内注释是不必要的，反而会分散注意力。

**Documentation Strings 文档字符串**     
  编写好的文档说明（也叫“docstrings”）的约定在PEP 257中永恒不变。
  要为所有的公共模块，函数，类以及方法编写文档说明。非公共的方法没有必要，但是应该有一个描述方法具体作用的注释。这个注释应该在def那一行之后。
  PEP 257 描述了写出好的文档说明相关的约定。特别需要注意的是，多行文档说明使用的结尾三引号应该自成一行

## 十一.命名规范 ##

**应避免的名字**  
  永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名。 
  在有些字体里，这些字符无法和数字0和1区分，如果想用‘l’，用‘L’代替。

**包名和模块名**    
模块应该用简短全小写的名字    
Python包名也应该使用简短全小写的名字，但不建议用下划线。   

**类名**   
类名一般使用首字母大写的约定。    
在接口被文档化并且主要被用于调用的情况下，可以使用函数的命名风格代替。     
注意，对于内置的变量命名有一个单独的约定：大部分内置变量是单个单词（或者两个单词连接在一起），首字母大写的命名法只用于异常名或者内部的常量。

**异常名**      
因为异常一般都是类，所有类的命名方法在这里也适用。   
你需要在异常名后面加上“Error”后缀（如果异常确实是一个错误）。

**全局变量名**         
约定和函数命名规则一样。            
通过 from M import * 导入的模块应该使用all机制去防止内部的接口对外暴露，或者使用在全局变量前加下划线的方式（表明这些全局变量是模块内非公有）。   


**函数名**              
函数名应该小写，如果想提高可读性可以用下划线分隔。 

**函数和方法参数**             
始终要将 self 作为实例方法的的第一个参数。                
始终要将 cls 作为类静态方法的第一个参数。                    
如果函数的参数名和已有的关键词冲突，在最后加单一下划线比缩写或随意拼写更好。因此 class_ 比 clss 更好。（也许最好用同义词来避免这种冲突）

**方法名和实例变量**            
遵循这样的函数命名规则：使用下划线分隔小写单词以提高可读性。    
在非共有方法和实例变量前使用单下划线。     
通过双下划线前缀触发Python的命名转换规则来避免和子类的命名冲突。   

**Constants 常量**            
常量通常定义在模块级，通过下划线分隔的全大写字母命名。例如： MAX_OVERFLOW 和 TOTAL。

**继承的设计**                
公共属性不应该有前缀下划线。                   
如果公共属性名和关键字冲突，在属性名之后增加一个下划线。这比缩写和随意拼写好很多。（然而，尽管有这样的规则，在作为参数或者变量时，‘cls’是表示‘类’最好的选择，特别是作为类方法的第一个参数。）                            
注意1：参考之前的类方法参数命名建议                     
对于单一的共有属性数据，最好直接对外暴露它的变量名，而不是通过负责的 存取器（accessor）/突变（mutator） 方法。请记住，如果你发现一个简单的属性需要成长为一个功能行为，那么Python为这种将来会出现的扩展提供了一个简单的途径。在这种情况下，使用属性去隐藏属性数据访问背后的逻辑。 
注意1：属性只在new-style类中起作用。                        
注意2：尽管功能方法对于类似缓存的负面影响比较小，但还是要尽量避免。                      
注意3：属性标记会让调用者认为开销（相当的）小，避免用属性做开销大的计算。                 
如果你的类打算用来继承的话，并且这个类里有不希望子类使用的属性，就要考虑使用双下划线前缀并且没有后缀下划线的命名方式。这会调用Python的命名转换算法，将类的名字加入到属性名里。这样做可以帮助避免在子类中不小心包含了相同的属性名而产生的冲突。                          
注意1：只有类名才会整合进属性名，如果子类的属性名和类名和父类都相同，那么你还是会有命名冲突的问题。            
注意2：命名转换会在某些场景使用起来不太方便，例如调试，__getattr__()。然而命名转换的算法有很好的文档说明并且很好操作。                    
注意3：不是所有人都喜欢命名转换。尽量避免意外的名字冲突和潜在的高级调用。

           
**公共和内部的接口**                   
任何向后兼容保证只适用于公共接口，因此，用户清晰地区分公共接口和内部接口非常重要。           
文档化的接口被认为是公开的，除非文档明确声明它们是临时或内部接口，不受通常的向后兼容性保证。所有未记录的接口都应该是内部的。                      
为了更好地支持内省（introspection），模块应该使用__all__属性显式地在它们的公共API中声明名称。将__all__设置为空列表表示模块没有公共API。 
即使通过__all__设置过，内部接口（包，模块，类，方法，属性或其他名字）依然需要单个下划线前缀。                       
如果一个命名空间（包，模块，类）被认为是内部的，那么包含它的接口也应该被认为是内部的。            
导入的名称应该始终被视作是一个实现的细节。其他模块必须不能间接访问这样的名称，除非它是包含它的模块中有明确的文档说明的API，例如 os.path 或者是一个包里从子模块公开函数接口的 __init__ 模块。            

**十二.一些建议**    
和像None这样的单例对象进行比较的时候应该始终用 is 或者 is not，永远不要用等号运算符。   
使用 is not 运算符，而不是 not … is 。虽然这两种表达式在功能上完全相同，但前者更易于阅读，所以优先考虑。

	if foo is not None:

始终使用def表达式，而不是通过赋值语句将lambda表达式绑定到一个变量上。  

	def f(x): return 2*x

适当地使用异常链接。   
当捕获到异常时，如果可以的话写上具体的异常名，而不是只用一个except: 块。  

	try:
    	import platform_specific_module
	except ImportError:
    	platform_specific_module = None

为了避免和原来基于逗号分隔的语法出现歧义，Python3只支持这一种语法。    
当捕捉操作系统的错误时，推荐使用Python 3.3 中errno内定数值指定的异常等级。    
另外，对于所有的 try/except 语句块，在try语句中只填充必要的代码，这样能避免掩盖掉bug。  

	try:
    	value = collection[key]
	except KeyError:
    	return key_not_found(key)
	else:
    	return handle_value(value)

当代码片段局部使用了某个资源的时候，使用with 表达式来确保这个资源使用完后被清理干净。  
无论何时获取和释放资源，都应该通过单独的函数或方法调用上下文管理器。  

	with conn.begin_transaction():
    	do_stuff_in_transaction(conn)


返回的语句保持一致。函数中的返回语句都应该返回一个表达式，或者都不返回。如果一个返回语句需要返回一个表达式，那么在没有值可以返回的情况下，需要用 return None 显式指明，并且在函数的最后显式指定一条返回语句（如果能跑到那的话）。    

	def foo(x):
    	if x >= 0:
        	return math.sqrt(x)
    	else:
        	return None

	def bar(x):
    	if x < 0:
        	return None
    	return math.sqrt(x)

使用 ”.startswith() 和 ”.endswith() 代替通过字符串切割的方法去检查前缀和后缀。

	if foo.startswith('bar')

对象类型的比较应该用isinstance()而不是直接比较type。

	if isinstance(obj, int):

对于序列来说（strings，lists，tuples），可以使用空序列为false的情况   
书写字符串时不要依赖单词结尾的空格，这样的空格在视觉上难以区分，有些编辑器会自动去掉他们（比如 reindent.py。   
不要用 == 去和True或者False比较  

	if greeting:

功能注释：
如果代码希望对功能注释有不同的用途，建议在文件的顶部增加一个这种形式的注释   

	# type: ignore

















	



